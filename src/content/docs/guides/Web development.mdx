---
title: Handbook Web Developera
description: Poradnik w świecie web developmentu, jak zacząć i żyć?
---
import { Tabs, TabItem, Steps, FileTree } from '@astrojs/starlight/components';

## Środowisko

### WSL

Za używanie Windowsa do programowania jest wyrzucenie z koła, każdy obowiązkowo ma używać co najmniej WSL’a, a zalecany jest dual boot do Linuxa (rekomenduje ubuntu, bo proste)

- Tutorial dla opornych
  [https://www.youtube.com/watch?v=-atblwgc63E](https://www.youtube.com/watch?v=-atblwgc63E)

### Edytor

Używajcie VSCode, inne edytory na własną odpowiedzialność

OBOWIĄZKOWE wtyczki:

- [Prettier](https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode) - musicie go skonfigurować do formatowania przy zapisie i jako domyślny formater
  [https://www.youtube.com/watch?v=drtxWx1XojI](https://www.youtube.com/watch?v=drtxWx1XojI)
- [Eslint](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint) - będzie krzyczał na was jak coś źle zrobicie, tutaj wystarczy tylko kliknąć install

Polecane wtyczki:

- Tailwind CSS IntelliSense - podpowiedzi gdy piszecie klasy w tailwind, must have
- Better Comments - ładne komentarze
- Error Lens - od razu wam pokaże błędy, nie trzeba myszką najeżdżać
- Github Copilot - no chyba wiecie
- GitLens - ładny git blame w vscode

## Struktura plików

Używamy tej z [bulletproof-react](https://github.com/alan2207/bulletproof-react/blob/master/docs/project-structure.md), ale lekko przerobionej pod nasze potrzeby. Na start aplikacji polecam pominąć folder `features` i wszystko robić toplevel i dopiero później podzielić na featury.

<FileTree>

- next.config.ts
- tailwind.config.ts
- package.json
- src
  - app # tutaj są nasze wszystkie strony
    - layout.tsx
    - page.tsx
    - blog
      - [slug]
        - page.tsx
    - kontakt
      - page.tsx
  - assets # zdjęcia, czcionki i inne rzeczy
    - fajne_foto.webp
  - components # komponenty używane w całej aplikacji
    - FirstComponent.tsx
    - SecondComponent.tsx
  - features/ # moduły podzielone na feature'y
  - hooks # hooki używane w całej aplikacji
    - useAuth.tsx
    - usePlan.tsx
  - test/ # utilites do testów + mocki
  - types/ # typy używane w całej aplikacji
  - utils # funkcje używane w całej aplikacji
    - db.ts
    - lib.ts

</FileTree>

Każdy feature ma taką strukturę:

<FileTree>

- src/features/awesome-feature
  - api/ # exported API request declarations and api hooks related to a specific feature
  - assets/ # static files
  - components/ # components scoped to a specific feature
  - hooks/ # hooks scoped to a specific feature
  - atoms/ # atomy używane w konkretnym featuerze
  - types/ # typescript types used within the feature
  - utils/ # utility functions for a specific feature

</FileTree>

## Assumptions

Wszystko w programowaniu ma swoje mocne i słaby strony i wszystko zależy od tego co chcemy osiągnąć, ten poradnik jest zoptymalizowany pod (w kolejności od najważniejszego):

1. Szybkość developmentu - pisanie kodu powinno być jak najprostsze i jak najszybsze, jesteśmy kołem naukowym, każdy robi tutaj po godzinach i nie mamy budżetu na marnowanie czasu na zbędne rzeczy
2. Nowoczesność - jak już robimy coś za darmo, to miejmy z tego frajde, nie wiem jak wy, ja bym nie chciał pisać w angularze 😭
3. Uniwersalność - nie ma tutaj specjalistycznych rzeczy, starałem się, żeby jak najbardziej dało się przenosić wiedzę między apkami

Pod co nie jest zrobiony ten guide:

1. Długowieczność - większość bibliotek tutaj używanych potrafi bardzo szybko się zmieniać (patrz nextjs) i projekty, które nie będę dotykane przez rok będzie można już nazywać legacy, aka [stałocieplny software](https://blog.jim-nielsen.com/2024/cold-blooded-software/)
2. Learning curve - technologie takie jak React, NextJS są stosunkowo trudne do nauczania się dla osoby, która nic nie wie, tutaj o wiele lepiej by się sprawdził czysty html i js

## Technologie

### Typescript

Nie widzę powodów, żeby nie używać Typescripta:

- Ma niski próg wejścia
- OLBRZYMIA wartość dla programisty
- Używany przez pół świata

### shadcn/ui

Komponenty, które z miejsca są ładne, customizowalne i na dodatek multum ludzi ich używa.

### React

Najpopularniejsza obecnie biblioteka (która działa jak framework) do tworzenia UI, klasyczek.

### Reszta:

- NextJS

- React Hook Form

- shadcn/ui

- Tanstack Query

- Jotai

- TailwindCSS

## Accessibility

### Opisy obrazków

Dobrą praktyką jest umieszczanie krótkiego opisu obrazka poza samym src obrazka. Służy to czytnikom ekranów, z który korzystają, np. niewidomi oraz pomaga w SEO w Google i innych wyszukiwarkach. Sprawa jest bardzo prosta:

```jsx {8}
// app/page.tsx
import Image from 'next/image'

export function MyComponent() {
  return (
    <Image
      src="/next.svg"
      alt="Next.js logo" // Krótki opis grafiki
    />
  )
}
```

### Przyciski jako linki

Za wsadzanie linka w przycisk będę karał tygodniową chłostą, to nie jest poprawny html, sam react krzyczy, że nie można tak robić i czytniki ekranów się popierdolą jak spróbują to przeczytać

Jak zrobić Link, który wygląda jak przycisk: 
```jsx
// app/page.tsx
import Link from "next/link"
import { Button } from "@/components/ui/button"
 
export function ButtonAsChild() {
  return (
    <Button asChild>
      <Link href="/login">Login</Link>
    </Button>
  )
}
```

:::tip
Jeśli ktoś pragnie doedukować się bardziej szczegółowo w temacie "Accessibility" zachęcam do obczajenia [dokumentacji React'a](https://legacy.reactjs.org/docs/accessibility.html), ale to tylko dla zaprawionych w boju w ramach ciekawostki.
:::

## Best practices

### Jak zrobić ładne UI?

Wbrew przekonaniom, sprawa jest prosta:

1. Znajdź stronę, której design Ci się podoba i pasuje do Twojego projektu, np. robisz apke z mapą? google maps
2. Skopiuj design 1:1, uprość i przerób go na komponenty shadcn
3. Gotowe, ciesz się ładnym designem

W UI/UX nie ma miejsca na kreatywność i jeśli sami spróbujecie stworzyć własny design na 99% skończycie z czymś dziwnym czego użytkownicy nie chcą używać. Jak tylko możecie kradnijcie designy i dostosowujcie do swoich potrzeb, użytkownicy chcą używać stron, które już znają i nie da sie sprawić by nie znali waszej stronę jeśli wygląda tak samo jak instagram 😭

Poza tym, nie pisz własnych komponentów jeśli nie masz BARDZO dobrego powodu, te z shadcn’a są bardzo ładne i jak tylko możesz używaj ich 1:1, wtedy na pewno nie zbłądzisz.

- Jak chcesz wiedzieć więcej na ten temat zapraszam do poczytania Refactoring UI, książka twórców tailwinda, poradnik o designie dla programistów (wymagany dostęp do dysku)
  [https://drive.google.com/file/d/1zbsgxcK-xREkmFV7D6Z1lHZwOn4k04w-/view?usp=drive_link](https://drive.google.com/file/d/1zbsgxcK-xREkmFV7D6Z1lHZwOn4k04w-/view?usp=drive_link)

### Pobieranie danych z API

Tutaj mamy dwie ścieżki:

1. React Server Components

   React Server Components (RSC) to domyślne podejście w Next.js 14+. Dzięki nim dane są pobierane po stronie serwera, co eliminuje konieczność zarządzania stanami ładowania i zapewnia szybsze ładowanie stron. Zaletami jest automatyczne renderowanie danych na serwerze, brak konieczności zarządzania stanami ładowania i są proste w użyciu.

    ```jsx {5-6}
    // app/products/page.tsx

    export default async function ProductsPage() {
      // Pobieranie danych z API po stronie serwera
      const data = await fetch('https://api.example.com/data');
      const products = await data.json();

      return (
        <div>
          <h1>Produkty</h1>
          <ul>
            {products.map((product) => (
              <li key={product.id}>
                {product.name} - {product.price} PLN
              </li>
            ))}
          </ul>
        </div>
      );
    }
    ```

2. Tanstack Query

   Tego używamy gdy chcemy mieć większą kontrolę nad tym co się dzieje w naszej aplikacji, potrzebujemy odświeżać często dane albo na przykład mamy jakąś skomplikowaną logikę po stronie klienta (typu użytkownik najpierw wybiera jakąś zakładkę i dopiero wtedy pobieramy coś z api albo jakikolwiek case z bardziej zaawansowanym filtrowaniem)

    <Tabs>
      <TabItem label="Zewnętrzne API">
        ```jsx {2, 10-12}
        // app/products/page.tsx
        "use client"

        import { useQuery } from '@tanstack/react-query';

        export default function ProductsList() {
          const { data: products, isLoading, error, refetch } = useQuery({
            queryKey: ['products'],
            queryFn: async () => {
              const data = await fetch('https://api.example.com/data');
              const products = await data.json();
              return products
            },
          })

          if (isLoading) return <p>Ładowanie danych...</p>;
          if (error) return <p>Wystąpił błąd podczas pobierania danych.</p>;

          return (
            <ul>
              {products.map((product) => (
                <li key={product.id}>
                  {product.name} - {product.price} PLN
                </li>
              ))}
            </ul>
          );
        }
        ```
      </TabItem>
      <TabItem label="Server Actions (NextJS)">
        ```ts {2, 11}
        // actions/products.ts
        "use server"

        import { db } from '@/lib/db';
        /** 
        * PAMIĘTAJCIE, że tego typu akcje serwerowe są automatycznie generowanymi
        * endpointami API, więc każdy może przy odrobinie umiejętności wykonać swoje rządanie do tej funkcji.
        * Trzeba zawsze zabezpieczyć taką funkcję, jeśli robimy rzeczy tylko dla zalogowanych użytkowników, np zmiana nazwy.
        */
        export async function fetchProducts() {
          return await db.products.findMany(); // Przykład z bazą danych
        }
        ```

        ```jsx {2, 10}
        // app/products/page.tsx
        "use client"

        import { useQuery } from '@tanstack/react-query';
        import { fetchProducts } from '@/actions/products.ts';

        export default function ProductsList() {
          const { data: products, isLoading, error, refetch } = useQuery({
            queryKey: ['products'],
            queryFn: fetchProducts,
          })

          if (isLoading) return <p>Ładowanie danych...</p>;
          if (error) return <p>Wystąpił błąd podczas pobierania danych.</p>;

          return (
            <ul>
              {products.map((product) => (
                <li key={product.id}>
                  {product.name} - {product.price} PLN
                </li>
              ))}
            </ul>
          );
        }
        ```
      </TabItem>
    </Tabs>

    


Do pobierania danych też potrzeba klienta API i tutaj mam zachęcam do korzystania z natywnego `fetch` , a za używanie `axios`a bez powodu będę ucinał pensje, jest bardzo mało powodów do używania axiosa w 2024 roku.

### Wysyłanie danych do API

Tutaj jestem opinionated i według mnie jedynym słusznym wyborem jest Tanstack Query i jego mutacje, nie próbujcie tego robić inaczej, bo będziecie sobie pluć w brodę (albo ja wam)

### Zarządzanie stanem

Do globalnego stanu używamy [Jotai](https://jotai.org/), a do lokalnego useState/useReducer jak serio to jest coś skomplikowanego

Nigdy Context API, chyba, że macie BARDZO dobry powód

### Formularze

Zapraszam do dokumentacji shadcn’a, tam większość jest dobrze opisana:

[https://ui.shadcn.com/docs/components/form](https://ui.shadcn.com/docs/components/form)

### Autentykacja

Nie mieliśmy jeszcze za dużo projektów, które by wymagały autentykacji, ale tutaj raczej zalecam iść w klasykę i klepnąć to w [AuthJS](https://authjs.dev/). Jest to rozwijany od lat produkt, który można 
w łatwy sposób zintegrować z projektem w NextJS. Zawiera duży funkcji, takich jak logowanie OAuth2 czy magicznymi linkami, sesje bazujące na bazie danych lub tokenach JWT czy automatyczną ochronę przed CSRF.
Ma dobrze rozwiniętą społeczność i dokumentację oraz masę tutoriali na YouTubie.

Dodatkowo w ramach ciekawostki podrzucam Wam projekt działający pod nazwą [BetterAuth](https://www.better-auth.com/). 
Jest to stosunkowo nowy projekt, który w wersję stabilną wszedł w listopadzie 2024 roku, aczkolwiek jest dobrze przemyślany i aktywnie rozwijany.
Zalety tego projektu to między innymi, jeszcze łatwiejsza instalacja niż AuthJS czy rozwiązanie pluginowe, np. jeśli potrzebujecie użyć Passkeys to dodajecie taki plugin do configu.
Do tego bardzo prosta dokumentacja. Polecam się zabawić.

Jeśli robicie to DIY, to pewnie będziecie musieli sobie odpowiedzieć na pytanie gdzie trzymać tokeny i tutaj są dwie opcje:

- LocalStorage - protsza opcja, ale mniej bezpieczna i bardziej podatna na ataki XSS
- Cookies HttpOnly - bardziej bezpieczna opcja, ale trudniejsza w implementacji, źle zaimplementowane może prowadzić do ataków CSRF

Na potrzeby Solvro cokolwiek wybierzecie będzie dobrze, a jeśli kogoś temat bardziej interesuje to tutaj można sobie poczytać:

- https://tkacz.pro/how-to-securely-store-jwt-tokens
- https://stackoverflow.com/questions/27067251/where-to-store-jwt-in-browser-how-to-protect-against-csrf

### Landing page

Jeśli jeszcze raz ktoś zmarnuje czas na robienie własnego landing page’a to go uduszę, tutaj macie dwie templatki i proszę z nich zrzynać:

- [https://shadcn-landing-page.vercel.app](https://shadcn-landing-page.vercel.app/)
- [https://shadcn-landing-page-livid.vercel.app](https://shadcn-landing-page-livid.vercel.app/)

### Analityka

Do analityki mamy postawione [Umami](https://umami.is/) na [https://analytics.solvro.pl](https://analytics.solvro.pl), jak chcecie dostęp to uderzajcie do Zarządu.

### WYSIWYG

Strasznie nie lubię tego tematu, bo tu jest milion wyborów i milion + 1 złych, obecnie rekomenduje:

[https://shadcn-minimal-tiptap.vercel.app/](https://shadcn-minimal-tiptap.vercel.app/)

### Tabelki

Do tworzenia bardziej zaawansowanych tabelek polecam [https://tanstack.com/table/latest](https://tanstack.com/table/latest). Jest dość skomplikowany i ma wysoki próg wejścia, ale pozwoli wam na wszystko co sobie wymyślicie.

Jako przykład polecam DataTable z shadcn'a:
[https://ui.shadcn.com/docs/components/data-table](https://ui.shadcn.com/docs/components/data-table)

Jeśli tabelka ma więcej niż 1000 wierszy to jest moment, żeby przenieść logikę filtrowania, paginacji i sortowania na backend, frontend przy takich ilościach powoli może zacząć zamulać. Przy 10k+ ilości wierszy to jest must-have.

### Deployment

Tutaj zapraszam do korzystania z naszego coolify’a pod adresem [https://devops.solvro.pl/](https://devops.solvro.pl/), jak ktoś chce dostępy to pisać do Zarządu, raczej każdy dostaje 😭

### a11y

Za wsadzanie linka w przycisk będę karał tygodniową chłostą, to nie jest poprawny html, sam react krzyczy, że nie można tak robić i czytniki ekranów się popierdolą jak spróbują to przeczytać

Jak zrobić Link, który wygląda jak przycisk: [https://ui.shadcn.com/docs/components/button#as-child](https://ui.shadcn.com/docs/components/button#as-child)

## Daty

Uff, to jest ciężki temat. Każdy kiedyś zetknie się z datami (lub już się zetknął) i bez odpowiednich narzędzi potrafi to być czasem droga przez mękę. Te wszystkie strefy czasowe, wyświetlanie w różnych formatach, porównywanie itd. 

Nasz naczelny Żelownik Bartuś podrzucił libkę o nazwie **date-fns**. Popieram go całym serduszkiem i dzięki niej mam nadzięję sprawię, że to daty będą bały się Was a nie na odwrót.

:::tip
Jeśli szukasz jakie literki wykorzystać do osiągnięcia zamierzonego efektu w formatowaniu, zapraszam do rozdziału niżej pt. "Dziwne literki do formatowania"
:::

### Basic usage

<Steps>

1. Dodaj libke

   ```sh
   npm i date-fns
   ```

2. Zaimportuj funkcję `format` z libki:

   ```jsx
   import { format } from 'date-fns';
   ```

3. Używaj jako `format(data, formater)`.

</Steps>

### Formatowanie daty

Użycie funkcji `format` do sformatowania daty w czytelny sposób.

```jsx
import { format } from 'date-fns';

export default function HomePage() {
  const today = new Date(); // 27 listopada 2024
  const formattedDate = format(today, 'dd/MM/yyyy'); // np. 27/11/2024

  return (
    <h1>Dzisiejsza data: {formattedDate}</h1>
  );
}
```

### Dodawanie dni do daty

Użycie funkcji `addDays`, aby obliczyć przyszłe daty.

```jsx
import { addDays, format } from 'date-fns';

export default function HomePage() {
  const today = new Date(); // 27 listopada 2024
  const futureDate = addDays(today, 7); // Data za 7 dni
  const formattedFutureDate = format(futureDate, 'dd MMMM yyyy'); // np. 04 grudnia 2024

  return (
    <h1>Data za tydzień: {formattedFutureDate}</h1>
  );
}
```

### Porównywanie dat

Sprawdzanie, czy jedna data jest przed lub po innej.

```jsx
import { isBefore, isAfter } from 'date-fns';

export default function HomePage() {
  const today = new Date(); // 27 listopada 2024
  const eventDate = new Date(2024, 11, 31); // 31 grudnia 2024

  const isEventInFuture = isAfter(eventDate, today);

  return (
    <div>
      <h1>{isEventInFuture ? 'Wydarzenie jest w przyszłości!' : 'Wydarzenie już się odbyło.'}</h1>
    </div>
  );
}
```

### Lokalizacja dat

Formatowanie daty w języku np. Angielskim za pomocą opcji `locale`.

```jsx
import { format } from 'date-fns';
import { en } from 'date-fns/locale';

export default function HomePage() {
  const today = new Date(); // 27 listopada 2024
  const formattedDate = format(today, 'EEEE, d MMMM yyyy', { locale: en }); // np. środa, 27 listopada 2024

  return (
    <h1>Dzisiejsza data: {formattedDate}</h1>
  );
}
```

### Obliczanie różnicy między datami

Użycie `differenceInDays` do obliczenia liczby dni między dwiema datami.

```jsx
import { differenceInDays } from 'date-fns';

export default function HomePage() {
  const today = new Date(); // 27 listopada 2024
  const newYear = new Date(2025, 0, 1); // 1 stycznia 2025

  const daysUntilNewYear = differenceInDays(newYear, today);

  return ( 
    <h1>Do Nowego Roku zostało: {daysUntilNewYear} dni</h1> 
  );
}
```

### Wyświetlanie upływu czasu

Wyświetlanie, ile czasu upłynęło od podanej daty za pomocą `formatDistance`, np. `10 sekund temu`.

```jsx
import { formatDistance } from 'date-fns';
import { pl } from 'date-fns/locale';

export default function HomePage() {
  const eventDate = new Date(2024, 10, 1); // 1 listopada 2024
  const today = new Date();

  const timePassed = formatDistance(eventDate, today, { addSuffix: true, locale: pl });

  return (
    <h1>Wydarzenie miało miejsce {timePassed}.</h1>
  );
}
```

### Dziwne literki do formatowania

Do formatowania dat używamy literek. Każda znaczy co innego. Ważne jest również, czy jest duża czy mała. Szybka ściągawka z najpotrzebniejszymi robaczkami.

| Litera | Opis                                   | Przykład (dla `2024-11-27 04:07:09`) |
|--------|----------------------------------------|--------------------------------------|
| **d**  | Dzień miesiąca (bez zera na początku) | `27`                                |
| **dd** | Dzień miesiąca (z zerem na początku)  | `27`                                |
| **E**  | Skrócony dzień tygodnia               | `Wed`                               |
| **EEEE**| Pełna nazwa dnia tygodnia            | `Wednesday`                         |
| **M**  | Miesiąc (bez zera na początku)        | `11`                                |
| **MM** | Miesiąc (z zerem na początku)         | `11`                                |
| **MMM**| Skrócona nazwa miesiąca               | `Nov`                               |
| **MMMM**| Pełna nazwa miesiąca                 | `November`                          |
| **yy** | Ostatnie dwie cyfry roku              | `24`                                |
| **yyyy**| Pełny rok                            | `2024`                              |
| **H**  | Godzina w formacie 24-godzinnym       | `14`                                |
| **HH** | Godzina w formacie 24-godzinnym (z zerem) | `14`                            |
| **h**  | Godzina w formacie 12-godzinnym       | `2`                                 |
| **hh** | Godzina w formacie 12-godzinnym (z zerem) | `02`                             |
| **a**  | AM/PM                                 | `PM`                                |
| **m**  | Minuty (bez zera na początku)         | `7`                                 |
| **mm** | Minuty (z zerem na początku)          | `07`                                |
| **s**  | Sekundy (bez zera na początku)        | `9`                                 |
| **ss** | Sekundy (z zerem na początku)         | `09`                                |
| **XXX**| Strefa czasowa z dwukropkiem          | `+01:00`                            |
| **x**  | Czas w milisekundach od UNIX Epoch    | `1732610829000`                     |

:::note
Do pełej dokumentacji o formatowaniu i literkach mogę odesłać pod [tym linkiem](https://date-fns.org/v4.1.0/docs/format)
:::

Robaczki można dowolnie łączyć. Kilka przykładów:

```jsx
const date = new Date();
const formatted = format(date, 'EEEE, d MMMM yyyy', { locale: pl }); 
console.log(formatted); // środa, 27 listopada 2024
```

```jsx
const formatted = format(new Date(), 'dd.MM.yyyy HH:mm:ss');
console.log(formatted); // 27.11.2024 14:07:09
```

```jsx
const formatted = format(new Date(), 'hh:mm a');
console.log(formatted); // 02:07 PM
```

## Strefy czasowe

Strefy czasowe to też spory temat, więc postanowiłem zrobić dla nich osobny rodział. Aby używać `date-fns` dla stref czasowych potrzebujemy specjalnego pakietu o nazwie `date-fns-tz`.

### Get started

<Steps>

1. Dodaj dodatkowy pakiet

   ```sh
   npm i date-fns date-fns-tz
   ```

</Steps>

### Wyświetlanie daty w konkretnej strefie czasowej

Użyj funkcji `formatInTimeZone` z biblioteki `date-fns-tz`.

```jsx
import { formatInTimeZone } from 'date-fns-tz';

export default function HomePage() {
  const now = new Date();
  const timeZone = 'Europe/Warsaw';

  const formattedDate = formatInTimeZone(now, timeZone, 'yyyy-MM-dd HH:mm:ss XXX'); // Aktualny czas w Warszawie: 2024-11-27 14:30:00 +01:00

  return (
    <h1>Aktualny czas w Warszawie: {formattedDate}</h1>
  );
}
```

### Przekształcenie daty z jednej strefy czasowej na inną

Użyj funkcji `utcToZonedTime` i `format` z `date-fns` oraz `date-fns-tz`.

```jsx
import { utcToZonedTime, format } from 'date-fns-tz';

export default function HomePage() {
  const utcDate = new Date('2024-11-27T12:00:00Z'); // Data w UTC
  const timeZone = 'America/New_York';

  // Konwersja na strefę czasową
  const zonedDate = utcToZonedTime(utcDate, timeZone);

  // Formatowanie daty w strefie czasowej
  const formattedDate = format(zonedDate, 'yyyy-MM-dd HH:mm:ss XXX', { timeZone }); // Czas w Nowym Jorku: 2024-11-27 07:00:00 -05:00

  return (
    <h1>Czas w Nowym Jorku: {formattedDate}</h1>
  );
}
```

### Obliczanie różnicy czasu między strefami

Możesz obliczyć różnicę w godzinach między dwiema strefami czasowymi, używając kombinacji `utcToZonedTime` i zwykłego obliczenia różnicy dat.

```jsx
import { utcToZonedTime, differenceInHours } from 'date-fns-tz';

export default function HomePage() {
  const now = new Date();
  const timeZone1 = 'Europe/Warsaw';
  const timeZone2 = 'Asia/Tokyo';

  const timeInWarsaw = utcToZonedTime(now, timeZone1);
  const timeInTokyo = utcToZonedTime(now, timeZone2);

  const hourDifference = differenceInHours(timeInTokyo, timeInWarsaw); // Różnica czasu między Warszawą a Tokio: 8 godzin

  return (
    <h1>Różnica czasu między Warszawą a Tokio: {hourDifference} godzin</h1>
  );
}
```




## Checklista przed wypuszczeniem aplikacji

<Steps>

1. **Czy masz favicon:**
   
   W **Next.JS** wystarczy podmienić default plik `favicon.ico` na swój.

2. **Czy masz ustawiony title, description i inne metadata na każdej stronie?**

    Szczegółowa dokumentacja Next.JS znajduje się [tutaj](https://nextjs.org/docs/app/building-your-application/optimizing/metadata). Szybki przykład:

    ```jsx
    // app/layout.tsx
    export const metadata: Metadata = {
      title: 'Twój tytuł',
      description: 'I jakiś fajny opis',
      keywords: [ 'Next.js', 'Tag 2', 'Tag 3' ],
      openGraph: {...},
    };
    ```

    :::caution
    Ustawianie metadaty można wykonać tylko w komponencie serwerowym, tj. nie w plikach z `"use client"`
    :::

3. **Czy masz wpiętą analitykę i eventy?**

    Korzystając z Umami lub innej analityki, dodając ją za pomocą specjalnych bibliotek dostarczanych od danej analityki lub poprzez tag `<Script />` z `next/script`.

</Steps>

## Częste błędy

### Używanie useEffect tam gdzie nie trzeba

useEffect służy do synchronizowania stanu z zewnętrznym systemem (ref. dokumentacja reacta), jeśli w useEffecie nie macie odwołania do zewnętrznego systemu (localStorage, api serwera, inne api przeglądarki) to znaczy, że go źle użyliście, przykładowy zły kod:

```jsx
function handleMuscleClick(muscle: string) {
  setSelectedMuscles((prevSelectedMuscles) => {
    if (prevSelectedMuscles.includes(muscle)) {
      return prevSelectedMuscles.filter((m) => m !== muscle);
    } else {
      return [...prevSelectedMuscles, muscle];
    }
  });
}

useEffect(() => {
  table.getColumn("targetMuscle")?.setFilterValue(selectedMuscles);
}, [selectedMuscles, table]);
```

Tutaj synchronizujemy `selectedMuscles` z filtrowana wartościa z tabelce, tabelka żyje w świecie reacta i nie jest zewnętrznym systemem i równie dobrze możemy to zrobić w ten sposób:

```jsx
function handleMuscleClick(muscle: string) {
  const newSelectedMuscles = selectedMuscles.includes(muscle)
    ? prevSelectedMuscles.filter((m) => m !== muscle)
    : [...prevSelectedMuscles, muscle];

  table.getColumn("targetMuscle")?.setFilterValue(newSelectedMuscles);
  setSelectedMuscles(newSelectedMuscles);
}
```

Teraz jest bardzo jasne, że po kliknięciu na mięsień, zostaje też zupdate’owana tabelka.

Ten przykład jeszcze nie jest taki zły, przy 1 useEffectcie dość łatwo się połapać co się dzieje, przy 11 robi się już kłopot i raz u mnie w pracy przez coś takiego padła produkcja 😭

### Nieużywanie lub nadużywanie `useMemo`

Hook `useMemo` pozwala na zapamiętanie wyniku funkcji obliczeniowej między renderami komponentu, co może pomóc w optymalizacji wydajności aplikacji. Jest używany głównie w przypadku "drogich" obliczeń (obliczenia, które swoją złożonością mają istotny wpływ na wydajność), które nie muszą być wykonywane na nowo przy każdym renderze.

Składnia:
```jsx
const memoizedValue = useMemo(() => computeValue(a, b), [a, b]);
```
- **computeValue**: Funkcja zwracająca wynik obliczeń.
- **[a, b]**: useMemo ponownie obliczy wartość tylko wtedy, gdy jedna z zależności w tej tablicy się zmieni.

#### Kiedy używać `useMemo`?

- Przy "kosztownych" obliczeniach, takich jak złożone przekształcenia dużych ilości danych.
- Kiedy wynik obliczeń jest wielokrotnie używany w danym renderze (np. w innych hookach).
- Przy obliczeniach, które zależą od dynamicznie zmieniających się danych.

#### Kiedy nie używać `useMemo`?

- Jeśli obliczenia są szybkie i nie mają zauważalnego wpływu na wydajność.
- Gdy dodanie useMemo bardziej komplikuje kod niż przynosi korzyści.
- Gdy zależności często się zmieniają, co może prowadzić do częstych ponownych obliczeń.

:::tip
Nie należy go używać na siłę. Najpierw upewnij się, że istnieje faktyczny problem z wydajnością, zanim go zastosujesz.
:::

## FAQ

- Co to Server Components i po co ich używać?

  RSC (React Server Components) to komponenty, których kodzik jest wykonywany WYŁĄCZNIE po stronie serwera i ani gram javascriptu nie idzie do przeglądarki, to są obecnie domyślne komponenty w Nextjs 13-15. Ułatwiają pobieranie danych z serwera, bo nie trzeba np. wyświetlać stanu loadingu, od razu otrzymujemy gotowe dane, możemy wykonywać zapytania do bazki od razu w kodzie komponentu co jest mega wygodne. Minus taki, że nie możecie tutaj używać żadnych hooków ani obsługiwać eventów, do tego są potrzebne Client Components.
  tl;dr;
  Kiedy używać RSC?
  Zawsze
  Kiedy używać Client Components?
  Wtedy kiedy nie możecie RSC (czyli potrzebujecie hooków itp)

  Dogłebniej opisane to jest tutaj: https://nextjs.org/docs/app/building-your-application/rendering/composition-patterns

- Jak działaja Client Components?

  Wbrew intuicji początkujących one są też wykonywane po stronie serwera (https://github.com/reactwg/server-components/discussions/4) i serwer wysyła gotowy html wraz z javascriptem, który potem jest wykonywany po stronie klienta i następuje proces hydracji, czyli React "przejmuje" html, który dostał i sam zaczyna go obsługiwać.

  Polecam bardzo opis z dokumentacji Nextjs, dobrze to opisali: https://nextjs.org/docs/app/building-your-application/rendering/client-components
