---
title: 2. Teoria gita
description: oto jak elozelujemy w solvro
sidebar:
  order: 2
---

W tym artykule opisz, po co jest nam git i jak u偶ywa jego g贸wnych funkcjonalnoci.

### Co to waciwie jest System Kontroli Wersji?

Wyobra藕 sobie, 偶e wprowadzie zmiany w projekcie. Okazao si, 偶e nie dziaaj tak, jak chciae i pr贸bujesz je cofn.

- Bez gita klikasz CTRL+Z i liczysz na to, 偶e buffer w IDE wystarczy na odwr贸cenie wszystkich zmian. Narazie jest nie藕le.
- Teraz wyobra藕 sobie, 偶e zmiany s porozrzucane po plikach, a IDE dla ka偶dego ma osobn histori. Robi si mniej wygodnie.
- Dodaj do tego, 偶e wsp贸tworzysz projekt z innymi osobami - nie mo偶ecie pracowa jednoczenie w obawie, 偶e zmiany bd niekompatybilne, a je偶eli bdziesz chcia co poprawi, nie masz atwego sposobu na przekazanie zmian innym bez zak贸cania ich pracy.

Co mo偶esz zrobi, 偶eby rozwiza ten problem?

Na myl przychodzi regularne tworzenie paczek zawierajcych kolejne wersje projektu, jednak praca, kt贸r trzeba by wo偶y w rczne zarzdzanie nimi prawdopodobnie przewy偶sza pisanie caych feature'贸w od nowa.

Git **bardzo** uatwia ten proces:

- Za pomoc tzw. _migawek_ (ang. snapshots) git ledzi zmiany w poszczeg贸lnych plikach.
- Migawki nie kopiuj plik贸w, kt贸re si nie zmieniy, dziki czemu zajmuj mao miejsca.
- Kiedy zapisujemy migawk, dostaje ona unikalny hashcode i jest zawsze dostpna w historii - mo偶emy si do niej cofn, sprawdzi, przywr贸ci (lub wykasowa, je偶eli zbyt si wstydzimy naszego starego kodu ).

### Jak skorzysta z tych benefit贸w?

#### Instalacja gita

[Tu mo偶ecie pobra gita](https://git-scm.com/downloads "github installer")

#### Podstawowy workflow gita

Aby zapisywa gdzie zmiany w oprogramowaniu, potrzebujemy utworzy **repozytorium** - ukryty folder w naszym projekcie, kt贸ry zawiera pliki i metadane potrzebne gitowi do poprawnego dziaania.
U偶ywamy do tego komendy:

`git init`

Tworzy ona ukryty folder ze wszystkimi plikami potrzebnymi gitowi do dziaania.  
呕eby przekona si, 偶e wszystko zadziaao, mo偶emy u偶y podstawowej komendy do diagnostyki:

`git status`

Komenda ta pokazuje nazw aktualnej gazi (ale o tym zaraz) oraz ledzone i nieledzone pliki ze zmianami - przy utworzeniu repo bd to wszystkie pliki w folderze, w kt贸rym u偶ylimy `git init`.  
Mo偶emy dodawa pojedyncze pliki u偶ywaj komendy

`git add {nazwa_pliku}`  
lub doda wszystkie pliki z folderu, w kt贸rym aktualnie si znajdujemy oraz jego podfolder贸w:  
`git add .`

Niestety rzadko chcemy, aby **wszystko** znalazo si w repozytorium - z reguy nie musimy ledzi plik贸w generowanych przez IDE i przykadowo _nie ledzimy_ pliku .env z prywatnymi kluczami do API. W takim wypadku tworzymy plik _.gitignore_, gdzie dodajemy cie偶ki do plik贸w i folder贸w, kt贸re chcemy pomin. Najlepiej utworzy go od razu po stworzeniu repozytorium (istniej do tego r贸偶ne templatki) i uaktualnia w miar rozrastania si projektu.

Podstawowy workflow w git wyglda tak:

- robimy zmiany w dowolnej liczbie plik贸w
- dodajemy pliki z pomoc `git add`
- zapisujemy aktualny stan repozytorium komend `git commit`. Otwiera ona edytor tekstu, w kt贸rym mo偶emy doda opis zmian, jednak je偶eli dodamy do niej flag -m, mo偶emy pomin ten krok i poda opis w terminalu: `git commit -m "opis zmian"`

**Uwaga**: je偶eli u偶yjemy komendy `git add` do dodania ledzenia zmian w jakim pliku, a potem go zmodyfikujemy to git bdzie ledzi nieaktualn wersj - musimy ponownie u偶y `git add` przed zatwierdzeniem zmian.

Dobr zasadjest tworzenie commit贸w po ukoczeniu ka偶dego maego zadania: zmiany konfiguracji, usunicia zbdnych plik贸w czy dodania nowej funkcjonalnoci (tu **uwaga**: funkcjonalno mo偶e by zbyt du偶a na jeden commit).

Pliki mo偶emy usuwa komend:  
`git rm nazwa_pliku` (**uwaga**: ta komenda usuwa plik zar贸wno z repozytorium, jak i systemu plik贸w)  
`git rm --cached nazwa_pliku` (to pozwala zachowa plik na dysku, ale git przestaje go ledzi)

Mo偶emy r贸wnie偶 cofn i usun wszystkie zmiany do poprzedniego commita, u偶ywajc `git reset --hard`, jednak nale偶y u偶ywatego polecenia z rozwag, bo ju偶 go nie cofniemy.

Jednak偶e, je偶eli wszystkie migawki czyby liniowy zwizek, nie mo偶emy atwo prototypowa - jeli cofnlibymy si o kilka commit贸w i tam co zmienili, ryzykowalibymy, 偶e co wywali si nam w najnowszym commit'cie.

![Przykad z jedn gazi w git](../../../../assets/tutorials/git-basics/one-branch-ex.png)

Powy偶szy diagram pokazuje tworzenie commit'贸w na jednej gazi.
Za贸偶my, 偶e potrzebujesz przetestowa, jak wygldaj dwa r贸偶ne rozwizania - gupio byoby w tym celu kopiowa i izolowa cay projekt czy usuwa jedne rozwizanie na rzecz drugiego. Zamiast tego wystarczy utworzy dwie nowe gazie.

### Gazie (ang. branches)

![Przykad wielu gazi w git](../../../../assets/tutorials/git-basics/multi-branch-ex.png)

Gazie pozwalaj ci izolowa swoj prac na jednej wersji repozytorium, nie naruszajc innych.Mo偶esz na nich prototypowa nowe funkcjonalnoci bez przeszkadzania innym i rozwalania sobie kodu na gazi _main_.  
Aby utworzy now ga藕, u偶ywamy komendy:  
`git branch {nazwa_gazi}`

Przeczamy si na ni za pomoc:  
`git checkout {nazwa_gazi}`  
lub  
`git switch {nazwa_gazi}`

Mo偶emy od razu przeczy si na nowo utworzon ga藕, czc dwie czynnoci w:  
`git checkout -b {nazwa_gazi}`

Mo偶emy wywietli wszystkie dostpne gazie komend `git branch`.

Je偶eli mamy zmiany na jednej gazi i chcemy si przenie na inn, git nie pozwoli nam na to. Musimy je cofn lub zacommitowa - ale mo偶emy by np. w poowie wprowadzania funkcjonalnoci, gdzie commit nie ma sensu.

W takiej sytuacji mo偶emy u偶y `git stash` - komenda ta cofnie nasze zmiany z gazi i zapisze je w **_schowku_**.  
Kiedy wr贸cimy z powrotem na ga藕, gdzie u偶ylimy `git stash`, wystarczy u偶y `git stash pop` i przywr贸cimy j do stanu, w kt贸rym j zostawilimy.

### Merge & rebase

No dobrze, podobaj mi si moje zmiany, jak mog je doda do g贸wnej wersji projektu - gazi main?

Musimy poczy dwie gazie, a jest na to kilka sposob贸w.

- `git merge {nazwa_gazi_kt贸r_scalamy_z_obecn}`, kt贸ry scala dwie gazie, zachowujc ich osobne historie - to rozwizanie sprawia, 偶e historia jest bardziej skomplikowana i nieuporzdkowana,
  jednak pozwala na najdokadniejsze jej przegldanie. Tworzy osobny commit scalajcy gazie.
- `git rebase {nazwa_gazi_kt贸ra_ma_by_藕r贸dem_obecnej_gazi}` - rozwizanie wybierane najczciej ze wzgldu na to, 偶e pozwala zapobiec baaganowi w historii repozytorium
- `git merge --squash {nazwa_gazi_kt贸r_scalamy_z_obecn}` - r贸偶ni si od zwykego merge tym, 偶e nie tworzy dodatkowego commitu oraz spaszcza w jeden commit wszystkie commity z gazi, kt贸r chcemy scali z g贸wn gazi. Musimy potem go doda komend`git commit`.

#### Merge

![Git repo z 3 gaziami](../../../../assets/tutorials/git-basics/git-3-branches.png)

_Przy wikszej iloci gazi, trudno odczyta co z diagramu historii._

W przypadku zwykego merge zachowujemy szczeg贸owy dostp do wszystkich zmian, jednak tworzymy _merge commits_,
kt贸re zamiecaj histori oraz ryzykujemy og贸lny baagan w repozytorium z nieliniow histori.

##### Fast-forward merge

Je偶eli git wykryje, 偶e nie ma rozgazienia - bo np. nie byo 偶adnych commit'贸w na g贸wnej gaezi, nastpuje fast-forward merge.  
FF merge nie tworzy merge commit'a i zwyczajnie przenosi zmiany na g贸wn ga藕, zachowujc liniowhistori.

#### Merge --squash

![git merge z flag squash](../../../../assets/tutorials/git-basics/git-merge-squash-example.png)

_Tworzymy jeden du偶y commit w miejscu scalenia gazi_ `git merge --squash
feat_1` `git commit -m "abc"`

Na gazi, z kt贸r scalamy ga藕 poboczn powstaje tak zwany squash commit, zawierajcy wszystkie zmiany z gazi pobocznej.

Pozwala to zachowa liniow histori, jednak偶e tracimy szczeg贸y na temat tego, co si stao w poszczeg贸lnych commitach - je偶eli wprowadzony zosta bug, trudniej go wyledzi.

#### Rebase

![Przykad git rebase](../../../../assets/tutorials/git-basics/git-rebase-example.png)
_(bdc na gazi feat)_ `git rebase main`

Git rebase "przenosi" pocztek naszej gazi na koniec gazi 藕r贸dowej.
Pozwala to zachowa liniow histori zmian i nie tworzy zbdnych commit贸w.
Po rebase musimy jeszcze zmerge'owa zmiany - nastpuje wtedy fast-forward merge.  
`git checkout main`  
`git merge feat_1`

_Git rebase powinnimy u偶ywa tylko lokalnie, na gaziach, na kt贸rych pracujemy sami, aby nie wprowadza niepotrzebnych konflikt贸w._

#### Usuwanie gazi

Zbdne gazie usuwamy komend:
`git branch -d nazwa_gazi`  
lub `git branch -D nazwa_gazi`, by wymusi usunicie nie-zmergowanej gazi

#### Merge conflicts

Zdarza si, 偶e scalajc dwie gazie, kt贸re w midzyczasie byy modyfikowane, pojawiaj si **konflikty**.
Nie jest to nic strasznego, bo tak dugo, jak rozumiemy kod, a zmiany nie byy du偶ych rozmiar贸w rozwizywanie konflikt贸w jest bardzo proste.
W skonfliktowanych plikach znajdziemy takie oznaczenia:

![Przykad konflikt贸w w git](../../../../assets/tutorials/git-basics/git-conflict-example.png)

- HEAD - w tej sekcji s zmiany z gazi, na kt贸rej si znajdujemy
- Jest ona oddzielona od zmian z drugiej gazi za pomoc separatora "======="
- Na kocu mamy podane, jak nazywa si ga藕, kt贸rscalamy.

Jak wida, nowoczesne IDE umo偶liwia rozwizanie konflikt贸w jednym klikniciem myszy, je偶eli chcemy zaakceptowa zmiany tylko z jednej gazi lub wszystkie mo偶liwe zmiany.  
W innym wypadku musimy rcznie wybra zmiany, kt贸re akceptujemy, usuwajc resztzmian oraz znaczniki i separator.

Nastpnie musimy doda pliki z rozwizanymi konfliktami do gita:  
`git add {pliki}`  
`git commit -m "merge: nazwa_gazi"`

U偶ywajc git rebase, na ka偶dym etapie gdzie git napotka konflikty, rebase zostanie spauzowany i pozwoli ci je rozwiza. Po ich rozwizaniu mo偶esz kontynuowa rebase.
`git add {pliki}`  
`git rebase --continue`

W ka偶dym momencie rebase mo偶esz u偶y `git rebase --abort`, aby cofn si do stanu przed uruchomieniem komendy.

Git rebase to pot偶ne narzdzie, o kt贸rego mo偶liwociach polecam wicej poczyta - szczeg贸lnie jego interaktywny tryb jest przydatny.

### Further resources

[git-for-beginners-the-definitive-practical-guide](https://stackoverflow.com/questions/315911/git-for-beginners-the-definitive-practical-guide)  
[Interactive rebase](https://www.youtube.com/watch?v=42392W7SgnE)  
[Learn git branching](https://learngitbranching.js.org/)
