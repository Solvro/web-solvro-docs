---
title: 3. Testowanie
sidebar:
  order: 30
---

Jako programiÅ›ci nie jesteÅ›my Å›wiÄ™ci i czÄ™sto siÄ™ mylimy, dlatego tutaj sÄ… spisane czÄ™ste pomyÅ‚ki przy pisaniu kodu oraz jak moÅ¼na nim zaradziÄ‡.

### UÅ¼ywanie useEffect tam gdzie nie trzeba

useEffect sÅ‚uÅ¼y do synchronizowania stanu z zewnÄ™trznym systemem (ref. dokumentacja reacta), jeÅ›li w useEffecie nie macie odwoÅ‚ania do zewnÄ™trznego systemu (localStorage, api serwera, inne api przeglÄ…darki) to znaczy, Å¼e go Åºle uÅ¼yliÅ›cie, przykÅ‚adowy zÅ‚y kod:

```jsx
function handleMuscleClick(muscle: string) {
  setSelectedMuscles((prevSelectedMuscles) => {
    if (prevSelectedMuscles.includes(muscle)) {
      return prevSelectedMuscles.filter((m) => m !== muscle);
    } else {
      return [...prevSelectedMuscles, muscle];
    }
  });
}

useEffect(() => {
  table.getColumn("targetMuscle")?.setFilterValue(selectedMuscles);
}, [selectedMuscles, table]);
```

Tutaj synchronizujemy `selectedMuscles` z filtrowana wartoÅ›cia z tabelce, tabelka Å¼yje w Å›wiecie reacta i nie jest zewnÄ™trznym systemem i rÃ³wnie dobrze moÅ¼emy to zrobiÄ‡ w ten sposÃ³b:

```jsx
function handleMuscleClick(muscle: string) {
  const newSelectedMuscles = selectedMuscles.includes(muscle)
    ? prevSelectedMuscles.filter((m) => m !== muscle)
    : [...prevSelectedMuscles, muscle];

  table.getColumn("targetMuscle")?.setFilterValue(newSelectedMuscles);
  setSelectedMuscles(newSelectedMuscles);
}
```

Teraz jest bardzo jasne, Å¼e po klikniÄ™ciu na miÄ™sieÅ„, zostaje teÅ¼ zupdate'owana tabelka.

Ten przykÅ‚ad jeszcze nie jest taki zÅ‚y, przy 1 useEffectcie doÅ›Ä‡ Å‚atwo siÄ™ poÅ‚apaÄ‡ co siÄ™ dzieje, przy 11 robi siÄ™ juÅ¼ kÅ‚opot i raz u mnie w pracy przez coÅ› takiego padÅ‚a produkcja ğŸ˜­

### NieuÅ¼ywanie lub naduÅ¼ywanie `useMemo`

Hook `useMemo` pozwala na zapamiÄ™tanie wyniku funkcji obliczeniowej miÄ™dzy renderami komponentu, co moÅ¼e pomÃ³c w optymalizacji wydajnoÅ›ci aplikacji. Jest uÅ¼ywany gÅ‚Ã³wnie w przypadku "drogich" obliczeÅ„ (obliczenia, ktÃ³re swojÄ… zÅ‚oÅ¼onoÅ›ciÄ… majÄ… istotny wpÅ‚yw na wydajnoÅ›Ä‡), ktÃ³re nie muszÄ… byÄ‡ wykonywane na nowo przy kaÅ¼dym renderze.

SkÅ‚adnia:

```jsx
const memoizedValue = useMemo(() => computeValue(a, b), [a, b]);
```

- **computeValue**: Funkcja zwracajÄ…ca wynik obliczeÅ„.
- **[a, b]**: `useMemo` ponownie obliczy wartoÅ›Ä‡ tylko wtedy, gdy jedna z zaleÅ¼noÅ›ci w tej tablicy siÄ™ zmieni.

#### Kiedy uÅ¼ywaÄ‡ `useMemo`?

- Przy "kosztownych" obliczeniach, takich jak zÅ‚oÅ¼one przeksztaÅ‚cenia duÅ¼ych iloÅ›ci danych.
- Kiedy wynik obliczeÅ„ jest wielokrotnie uÅ¼ywany w danym renderze (np. w innych hookach).
- Przy obliczeniach, ktÃ³re zaleÅ¼Ä… od dynamicznie zmieniajÄ…cych siÄ™ danych.

#### Kiedy nie uÅ¼ywaÄ‡ `useMemo`?

- JeÅ›li obliczenia sÄ… szybkie i nie majÄ… zauwaÅ¼alnego wpÅ‚ywu na wydajnoÅ›Ä‡.
- Gdy dodanie useMemo bardziej komplikuje kod niÅ¼ przynosi korzyÅ›ci.
- Gdy zaleÅ¼noÅ›ci czÄ™sto siÄ™ zmieniajÄ…, co moÅ¼e prowadziÄ‡ do czÄ™stych ponownych obliczeÅ„.

:::tip
Nie naleÅ¼y go uÅ¼ywaÄ‡ na siÅ‚Ä™. Najpierw upewnij siÄ™, Å¼e istnieje faktyczny problem z wydajnoÅ›ciÄ…, zanim go zastosujesz.
:::

### Co to za bÅ‚Ä…d hydracji w React/Next.js?

JeÅ›li uÅ¼ywaliÅ›cie SSR (server-side-rendering) z hydracjÄ… po stronie klienta (czyli moÅ¼liwoÅ›Ä‡ zachowania reaktywnoÅ›ci strony przy jak najwiÄ™kszym renderowaniu po stronie serwera), to moÅ¼e napotkaliÅ›cie siÄ™ z bÅ‚Ä™dem w stylu `Hydration failed`:

![Next.js hydration failed error](../../../../../assets/webdev/image1.png)

Dzieje siÄ™ to, gdy jakakolwiek czÄ™Å›Ä‡ DOM-u ma innÄ… wartoÅ›Ä‡ po stronie serwera niÅ¼ po stronie klienta. Innymi sÅ‚owy -- wtedy, kiedy uÅ¼ywacie kodu niedeterministycznego wzglÄ™dem okresu, w jakim zachodzi hydracja.

PrzykÅ‚adami sytuacji, ktÃ³re mogÅ‚oby to wywoÅ‚aÄ‡ to **uÅ¼ywanie dat**, np przy countdownie lub **uÅ¼ywanie wartoÅ›ci losowo wygenerowanych**.

##### Sugerowane podejÅ›cia

1. Renderowanie niedeterministycznych wartoÅ›ci wyÅ‚Ä…cznie po stronie klienta
   Zanim nastÄ…pi hydracja, zwrÃ³Ä‡ wersjÄ™ komponentu bez treÅ›ci dynamicznej. Gdy komponent zostanie w peÅ‚ni zaÅ‚adowany, uÅ¼yj `useEffect` aby zaktualizowaÄ‡ komponent, co dzieje siÄ™ po stronie klienta.

   ```tsx
   function HydratedComponent() {
     const [isLoaded, setIsLoaded] = useState(false);
     const [currentDate, setCurrentDate] = useState(new Date());
     useEffect(() => {
       setIsLoaded(true);
       setCurrentDate(new Date());
     }, []);

     if (!isLoaded) return "Loading...";
     return currentDate.toLocaleDateString();
   }
   ```

2. Tymczasowe zaokrÄ…glanie wartoÅ›ci, aby w czasie hydracji nie zmienaiaÅ‚y siÄ™
   W przypadku dat, moÅ¼na uÅ¼yÄ‡ przybliÅ¼enia w takim stopniu, Å¼eby w przewidywanym czasie zaÅ‚adowania strony nie ulegÅ‚o ono zmianie.

   ```tsx
   /** Rounds the current date to the nearest `accuracy` milliseconds. */
   const getRoundedDate = (accuracy = 60000) =>
     new Date(Math.round(new Date().getTime() / accuracy) * accuracy);

   function HydratedComponent() {
     const [currentDate, setCurrentDate] = useState(getRoundedDate());
     return currentDate.toLocaleString();
   }
   ```

   :::caution
   W podanym powyÅ¼ej przykÅ‚adzie istnieje moÅ¼liwoÅ›Ä‡, Å¼e strona zostanie zaÅ‚adowana idealnie w momencie, gdy zaokrÄ…glenie obecnej daty nie bÄ™dzie deterministyczne.

   PrzykÅ‚ad: uÅ¼ytkownik odwiedzi stronÄ™ o `16:20:29.5`, wiÄ™c serwer zaokrÄ…gla datÄ™ do 16:20:00. PrzesyÅ‚anie z serwera skryptÃ³w JS trwa okoÅ‚o sekundy wiÄ™c kod klienta uruchamia siÄ™ o `16:20:30.5`, czyli w zaokrÄ…gleniu 16:21:00. W tym momencie wywala nam bÅ‚Ä…d poniewaÅ¼ wygenerowany DOM klienta rÃ³Å¼ni siÄ™ od DOM-u serwera.

   ZauwaÅ¼cie, Å¼e uÅ¼ywanie innej strategii zaokrÄ…glania nie pozbyÅ‚oby siÄ™ tego problemu: zamiana `round` na `floor` lub `ceil` oznaczyÅ‚aby, Å¼e problematycznÄ… godzinÄ… byÅ‚aby `16:20:59.5`.

   JeÅ›li wymagana jest stuprocentowa niezawodnoÅ›Ä‡, nie naleÅ¼y korzystaÄ‡ z tej metody.
   :::

Metoda #2 dziaÅ‚a w przypadku wartoÅ›ci, ktÃ³re moÅ¼na w jakimÅ› stopniu zaokrÄ…glaÄ‡ lub czyniÄ‡ mniej dokÅ‚adnymi. W zwiÄ…zku z tym, dla wartoÅ›ci losowo wygenerowanych (np. `Math.random()`), zaleca siÄ™ stosowanie metody #1.
