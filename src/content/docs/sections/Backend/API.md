---
title: Dokumentacja API
description: Jakie standardy API stosujemy w Solvro
---

## Przydatne linki

- Czym jest REST API?
  - [Wikipedia](https://en.wikipedia.org/wiki/REST) - ca≈Ça historia i dlaczego to istnieje
- Lista status code'√≥w HTTP:
  - <https://developer.mozilla.org/en-US/docs/Web/HTTP/Status>
  - [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes)
  - [Fajne kotki](https://http.cat/)
- Specyfikacje Open API od Swaggera:
  - https://swagger.io/resources/open-api/
- Projekt Adonis-Autoswagger:
  - <https://github.com/ad-on-is/adonis-autoswagger>
  - [Komentarze, z kt√≥rych mo≈ºna korzystaƒá do dokumentacji](https://github.com/ad-on-is/adonis-autoswagger?tab=readme-ov-file#-extend-controllers)
  - [Struktura `@responseBody` i przyk≈Çady](https://github.com/ad-on-is/adonis-autoswagger?tab=readme-ov-file#responsebody-examples)
  - [Przyk≈Çad jak mo≈ºemy okomentowaƒá funkcje w kontrolerze](https://github.com/ad-on-is/adonis-autoswagger?tab=readme-ov-file#practical-example)
- Inne rozwiƒÖzania dla ScalarUI:
  - <https://stackoverflow.com/questions/36634281/list-of-swagger-ui-alternatives>
  - [RapiDoc](https://rapidocweb.com/)

## Wstƒôp

Aby m√≥c dobrze wsp√≥≈Çpracowaƒá miƒôdzy frontendem i backendem wa≈ºnym jest, aby ustaliƒá w jaki spos√≥b komunikujemy siƒô miƒôdzy tymi warstwami. Istnieje wiele technologii lub rozwiƒÖza≈Ñ (np. SOAP, REST, GraphQL, gRPC), z kt√≥rych mo≈ºna skorzystaƒá, natomiast ustalenie jednego standardu czƒôsto bardzo u≈Çatwia prace miƒôdzy zespo≈Çami.

## REST

Najczƒô≈õciej wybieranym rozwiƒÖzaniem przez Solvro jest REST API, bo to dosyƒá proste, ma ca≈Çkiem dobrƒÖ elastyczno≈õƒá oraz pod kƒÖtami technicznymi mo≈ºna z nim du≈ºo wykonaƒá (np. paginacja).

### CRUD na bazie RESTu

Istnieje ≈Çatwa do zapamiƒôtania korelacja miƒôdzy CRUDem a metodami HTTP, kt√≥re sƒÖ wykorzystywane w REST API:

- Read lub odczytanie danego zasobu u≈ºywa metody `GET`
- Create lub stworzenie danego zasobu u≈ºywa metody `POST`
- Update lub aktualizacja danego zasobu u≈ºywa metody `PUT`
- Delete lub usuniƒôcie danego zasobu u≈ºywa metody `DELETE`

## Status Code'y

Przyjƒôto konwencje, w kt√≥rej `status code` otrzymanej odpowiedzi informuje nas, co siƒô sta≈Ço z danym ≈ºƒÖdaniem/zapytaniem. Istnieje piƒôƒá grup, do kt√≥rych mo≈ºna zaklasyfikowaƒá wszystkie odpowiedzi:

- `1XX` - informacyjne, u≈ºywane w celu gdy np. chcemy dowiedzieƒá siƒô czy dane zapytanie jest dalej wykonywane (musi byƒá ono spore lub trwaƒá d≈Çugo, aby nie da≈Ço siƒô go wykonaƒá od razu). Rzadko u≈ºywane ze wzglƒôdu na istnienie innych rozwiƒÖza≈Ñ: [Webhook](https://en.wikipedia.org/wiki/Webhook)
- `2XX` - pomy≈õlne wykonane dane zapytanie
- `3XX` - przekierowanie w celu dope≈Çnienia danego ≈ºƒÖdania
- `4XX` - co≈õ z≈Çego sta≈Ço siƒô po stronie klienta lub dane zapytanie nie mo≈ºe zostaƒá wykonane z danych powod√≥w
- `5XX` - co≈õ z≈Çego sta≈Ço siƒô po stronie serwera

## Przyk≈Çad

Chcemy uzyskaƒá liste klient√≥w, a nastƒôpnie dodaƒá do niej kolejnego, kt√≥ry chce siƒô zarejestrowaƒá.

Wykonujemy wiƒôc zapytanie do przyk≈Çadowego API, do kt√≥rego wysy≈Çamy dane zapytanie z metodƒÖ `GET`:

```
https://przykladowa.strona.pl/api/v1/users
```

Zapytanie do ≈õcie≈ºki `/api/v1/users` strony `https://przykladowa.strona.pl` mo≈ºemy podzieliƒá na 2 i wyt≈Çumaczyƒá w jakim celu istniejƒÖ:

- `/api/v1` informuje nas, i jest jednocze≈õnie konwencjƒÖ, ≈ºe korzystamy z API w wersji pierwszej. Je≈ºeli dany serwis, aplikacja dzia≈Ça ju≈º d≈Çugo, to deweloperzy mogliby chcieƒá "zaktualizowaƒá" ca≈Çy serwis do np. wersji `v2`, ale dla ju≈º wcze≈õniej zaprogramowanych, innych aplikacji nadal `v1` by≈Çoby dostƒôpne.
- `/users` jest zasobem, kt√≥ry pr√≥bujemy odczytaƒá, dodaƒá co≈õ do niego, zmodyfikowaƒá go lub co≈õ z niego usunƒÖƒá. W tym przypadku bƒôdƒÖ to u≈ºytkownicy danego portalu, a serwer powinien nam odes≈Çaƒá odpowied≈∫, kt√≥ra wyglƒÖda mniej wiƒôcej tak:

```json
[
  {
    "id": 1,
    "firstName": "Jan",
    "lastName": "Przyk≈Çadowy",
    "email": "jan.przykladowy@mail.pl",
    "password": "c3VwZXJfZHVwZXJfbmllc2Ftb3dpdGVfaGFzxYJvXzEyMw=="
  },
  {
    "id": 2,
    "firstName": "Karol",
    "lastName": "Solvrowski",
    "email": "karol.solvrowski@mail.pl",
    "password": "YWRvbmlzX3RvX25pZXNhbW93aXR5X2ZyYW1ld29ya186RA=="
  },
  {
    ...
  },
]
```

Z takƒÖ odpowiedziƒÖ mo≈ºemy ju≈º bezproblemowo wy≈õwietliƒá co≈õ w UI, lub zweryfikowaƒá, ≈ºe u≈ºytkownik, kt√≥ry chce siƒô u nas zarejestrowaƒá nie bƒôdzie mieƒá takiego samego maila.

Teraz, gdy chcemy wys≈Çaƒá zapytanie o dodanie u≈ºytkownika do tej listy, wystarczy tylko, ≈ºe zmienimy metodƒô z `GET` na `POST`! Jest to bardzo wygodne i logiczne co powinno szybko pom√≥c wdro≈ºyƒá ludzi w dzia≈Çanie, oraz w komunikacjƒô pomiƒôdzy zespo≈Çami.

Podczas gdy dostajemy atrybut `id` w odpowiedzi od serwera, niekt√≥re dane sƒÖ tworzone po jego stronie dla w≈Çasnej indentyfikacji. Wysy≈ÇajƒÖc pro≈õbƒô o stworzenie kolejnego u≈ºytkownika, nie podajemy tego atrybutu - zostanie on nadany automatycznie przez serwer. Przyk≈Çadowe body zapytania mo≈ºe wyglƒÖdaƒá tak:

```json
{
  "firstName": "Jakub",
  "lastName": "Techniczny",
  "email": "jakub.techniczny@mail.pl",
  "password": "moje_has≈Ço_jest_widoczne!"
}
```

Ale jak to?!? Tutaj widzimy has≈Ço Jakuba w niezaszyfrowanej formie! Nic bardziej mylnego - has≈Ço dƒÖ≈ºƒÖce do serwera jest czƒôsto w formie plaintext, natomiast jest ju≈º pod formƒÖ szyfrowania zapewnionego przez protok√≥≈Ç HTTPS, dlatego nie musimy siƒô baƒá o jego wyciekniƒôcie. Po stronie serwera dopiero zachodzi procedura szyfrowania, tak, aby tylko serwer m√≥g≈Ç zweryfikowaƒá, przy ponownym sprawdzeniu has≈Ça, czy po zastosowaniu tego samego algorytmu szyfrowania has≈Ço siƒô zgadza.

Je≈ºeli wszystko przebieg≈Ço pomy≈õlnie, serwer powinien odes≈Çaƒá nam odpowied≈∫ ze statusem 201 (Created) z przyk≈Çadowym body:

```json
{
  "id": 3,
  "firstName": "Jakub",
  "lastName": "Techniczny",
  "email": "jakub.techniczny@mail.pl"
}
```

NawiƒÖzujƒÖc te≈º do pierwszego zapytania, w kt√≥rym widzimy _zaszyfrowane_ has≈Ça, implementujƒÖc API powinni≈õmy pamiƒôtaƒá o jednej wa≈ºnej zasadzie. **Nie odsy≈Çamy niepotrzebnych dla u≈ºytkownika informacji z serwera**. Poprawnym, dla wy≈õwietlenia danych u≈ºytkownika w jego panelu, by≈Çoby wys≈Çanie nastƒôpujƒÖcych danych:

```json
{
  "id": 1,
  "firstName": "Jan",
  "lastName": "Przyk≈Çadowy",
  "email": "jan.przykladowy@mail.pl"
}
```

W dodatku takie zapytanie dostaliby≈õmy gdyby≈õmy wysy≈Çali zapytanie metodƒÖ `GET` na adres (lub inaczej m√≥wiƒÖc endpoint):

```
https://przykladowa.strona.pl/api/v1/users/1
```

Dlaczego dodali≈õmy `/1` na koniec zasobu `/users`? Istnieje konwencja, ≈ºe majƒÖc klucz g≈Ç√≥wny, tutaj atrybut `id`, mo≈ºemy dostaƒá wskazanego w zapytaniu u≈ºytkownika, nie muszƒÖc odsy≈Çaƒá niepotrzebnie ca≈Çej listy u≈ºytkownik√≥w w jednym zapytaniu. Jest to jednocze≈õnie kwestia optymalizacji - mniejsze zu≈ºycie sieci, serwera, filtrowania przez ca≈ÇƒÖ listƒô po stronie u≈ºytkownika, jak i bezpiecze≈Ñstwa - nie chcemy dawaƒá u≈ºytkownikowi nie jego danych.

## Swagger

Aby m√≥c ≈Çatwo komunikowaƒá siƒô i wiedzieƒá jakie sƒÖ endpointy na backendzie, przyda≈Çaby siƒô dokumentacja... dlatego z pomocƒÖ przychodzi projekt Swagger, kt√≥ry standaryzuje spos√≥b opisywania endpoint√≥w REST. Nastƒôpnie za pomocƒÖ r√≥≈ºnych aplikacji, mo≈ºna wygenerowaƒá dokumentacje, kt√≥ra pomaga np. sekcji frontend w szybkim i sprawnym tworzeniu logiki aplikacji.

### Autoswagger

Projekt Autoswagger pozwala na automatyczne wygenerowanie dokumentacji z kodu danego frameworku, a potem na wy≈õwietlanie go za pomocƒÖ np. ScalarUI na r√≥wnie automatycznie wygenerowanej stronie ü§Ø

### Adonis-Autoswagger

Dla naszego g≈Ç√≥wnego frameworku istnieje rozwiƒÖzanie, kt√≥re po zainstalowaniu jednego pakietu (i pakiet√≥w, na kt√≥rym siƒô on opiera) i kilku prostych zmian w kodzie dostajemy automatycznƒÖ dokumentacjƒô, kt√≥rƒÖ mo≈ºemy podpiƒÖƒá pod dowolny endpoint!

#### Instalacja frontendu dla swaggera (ScalarUI)

Po dok≈Çadne instrukcje i opis dzia≈Çania zapraszam na [stronƒô projektu](https://github.com/ad-on-is/adonis-autoswagger).

Wchodzimy do projektu z Adonisem i wpisujemy:

```
npm install adonis-autoswagger
```

Nastƒôpnie musimy napisaƒá konfiguracjƒô Autoswaggera, najlepiej w folderze `/config`. Plik mo≈ºe nazywaƒá siƒô jakkolwiek, natomiast konwencjƒÖ podanƒÖ przez projekt jest nazwanie go `swagger.ts`. Nastƒôpnie zamieszczamy tam nastƒôpujƒÖcƒÖ konfiguracje:

```ts
import path from "node:path";
import url from "node:url";

export default {
  path: `${path.dirname(url.fileURLToPath(import.meta.url))}/../`,
  tagIndex: 2,
  info: {
    title: "Niesamowity projekt od Solvro",
    version: "1.0.0",
    description: "Kolejny z niesamowitych projekt√≥w solvro - dokumentacja",
  },
  snakeCase: true,
  ignore: ["/swagger", "/docs"],
  preferredPutPatch: "PUT",
  common: {
    parameters: {},
    headers: {},
  },
  showFullPath: false,
};
```

Teraz mo≈ºemy zaktualizowaƒá `routes.ts`, aby Autoswagger wykry≈Ç nasze endpointy i automatycznie wygenerowa≈Ç dla nich dokumentacje:

Wszystkie statyczne kontrolery musimy zamieniƒá na lazy-loaded:

```ts
import TestController from "#controllers/test_controller"; //NIEPOPRAWNIE ‚ùå
const TestController = () => import("#controllers/test_controller"); //POPRAWNIE ‚úÖ
```

A w dodatku dodaƒá route'y dla ScalarUI i do zwracania dokumentacji w postaci YAMLa:

```ts
import AutoSwagger from "adonis-autoswagger";
import swagger from "#config/swagger"; //je≈ºeli plik konfiguracyjny jest w config/swagger.ts

import router from "@adonisjs/core/services/router";

//dokumentacja wygenerowana w postaci YAMLa
router.get("/swagger", async () => {
  return AutoSwagger.default.docs(router.toJSON(), swagger);
});

//dla Scalar UI, korzysta ze ≈õcie≈ºki /swagger do zaciƒÖgniƒôcia dokumentacji
router.get("/docs", async () => {
  return AutoSwagger.default.scalar("/swagger");
});
```

Teraz powinni≈õmy m√≥c wej≈õƒá na ≈õcie≈ºkƒô `/docs` i m√≥c zobaczyƒá naszƒÖ automatycznƒÖ dokumentacjƒô API! üéâ

#### Alternatywy ScalarUI (RapiDoc)

Istnieje [wiele innych rozwiƒÖza≈Ñ](https://stackoverflow.com/questions/36634281/list-of-swagger-ui-alternatives) dokumentujƒÖcych aplikacje za pomocƒÖ plik√≥w wed≈Çug standardu OpenAPI. Jednym z takich rozwiƒÖza≈Ñ jest [RapiDoc](https://rapidocweb.com/), kt√≥ry jest r√≥wnie≈º wbudowane w projekt Autoswagger i r√≥wnie ≈Çatwo zaimplementowaƒá to w projekcie.

Wystarczy, ≈ºe zamiast funkcji `.scalar("/swagger");` dla endpointa `/docs`, u≈ºyjemy `.rapidoc("/swagger")`:

```ts
router.get("/docs", async () => {
  return AutoSwagger.default.rapidoc("/swagger");
});
```

Przy czym pamiƒôtajmy, ≈ºe na jednej ≈õcie≈ºce mo≈ºe staƒá tylko **jeden** frontend, wiƒôc w przypadku chƒôci skorzystania z obydwu rozwiƒÖza≈Ñ, mo≈ºna stworzyƒá front RapiDoca, na przyk≈Çad na ≈õcie≈ºce `/rapidoc`.

### Dokumentacja endpoint√≥w

Korzystanie z Autoswaggera pozwala nam r√≥wnie≈º na automatycznƒÖ dokumentacje kodu, za pomocƒÖ komentarzy nad danƒÖ funkcjƒÖ w kontrolerze. Wszystkie opcje z wyt≈Çumaczeniem jak dzia≈ÇajƒÖ i jak mo≈ºna je u≈ºyƒá da siƒô znale≈∫ƒá [tutaj](https://github.com/ad-on-is/adonis-autoswagger?tab=readme-ov-file#-extend-controllers). Dla przyk≈Çadu:

```ts
/**
 * @index
 * @operationId getEvents
 * @description Returns admin events
 * @responseBody 200 - <Event[]>
 * @tag event
 */
public async index({ auth }: HttpContext) {
  await auth.user?.preload("events");
  return auth.user?.events;
}
```

- `@index` - informuje nas o tym, ≈ºe funkcja zwraca GET wszystkich event√≥w (indeksuje je dla odbiorcy)
- `@operationId` - customowe ID, kt√≥re jest unikatowe w ca≈Çej dokumentacji. Jednocze≈õnie powinno ono w miarƒô sygnalizowaƒá co robi dany endpoint
- `@description` - opis danego endpointu, nie musi byƒá d≈Çugi je≈ºeli operacja jest prosta, nastomiast dla bardziej z≈Ço≈ºonych powinno byƒá opisane jak dok≈Çadnie siƒô zachowuje
- `@responseBody` - w skr√≥cie: to co zwracamy. Mo≈ºe byƒá to dany typ z projektu, i≈º Autoswagger rozumie typy i stara siƒô je wkleiƒá do dokumentacji (przyjemna automatyzacja). W przypadku nietypowych zastosowa≈Ñ mo≈ºna wstawiƒá customowy JSON, kt√≥ry bƒôdzie odsy≈Çany przez API. Ca≈Ça lista tego jak mo≈ºemy to sformatowaƒá znajduje siƒô [tutaj](https://github.com/ad-on-is/adonis-autoswagger?tab=readme-ov-file#responsebody-examples)
- `@tag` - tag, za pomocƒÖ kt√≥rego mo≈ºemy przypisaƒá endpoint do danej grupy, aby ≈Çatwiej by≈Ço przeglƒÖdaƒá dokumentacje

#### Czƒôsto pope≈Çniane b≈Çƒôdy

Zdarza siƒô, ≈ºe w `@responseBody` nie damy poprawnego JSONa przez co silnik generowania dokumentacji nie bƒôdzie poprawnie formatowa≈Ç nam danego obiektu. Nie ma wbudowanego sposobu automatycznego sprawdzania czy na pewno jest poprawny. Warto sprawdziƒá online (lub wyƒáwiczonym okiem), czy na pewno w odpowiednich miejscach znajdujƒÖ siƒô cudzys≈Çowy.

Przyk≈Çad: `{ "hej": "kolego", slyszales: "ze", solvro: "jest cool?" }`

W tym przypadku `slyszales` nie ma cudzys≈Çow√≥w, przez co Autoswagger niepoprawnie odczyta atrybut lub kompletnie nie wy≈õwietli danego `@responseBody`.
