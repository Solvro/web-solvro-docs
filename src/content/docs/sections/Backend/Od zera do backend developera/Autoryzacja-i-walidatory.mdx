---
title: 4. Autoryzacja i walidatory
description: Autoryzacja, Walidatory
sidebar:
  order: 5
---

## WstÄ™p

Autoryzacja jest potrzebna w zasadzie w kaÅ¼dej aplikacji. Nawet jeÅ¼eli nasze API jest caÅ‚kowicie publiczne i dostÄ™pne dla kaÅ¼dego,
to przydaÅ‚oby siÄ™ aby nowe treÅ›ci moÅ¼na byÅ‚o dodaÄ‡ poprzez pewnego rodzaju panel administratora. W tym rozdziale zostanÄ… wytÅ‚omaczone podstawy
przebiegu i metod autoryzacji, opisane kilka dobrych praktyk zwiÄ…zanych z nimi oraz, dodatkowo, znajdzie siÄ™ sekcja o walidacji danych wejÅ›ciowych.


Kod zawarty w tym poradniki moÅ¼na zobaczyÄ‡ w caÅ‚oÅ›ci w [repozytorium z Wakacyjnego Wyzwania 2025](https://github.com/Solvro/backend-wakacyjne-wyzwanie-2025)

----------------

## Autoryzacja

### 1. â€Co zrobiÄ‡ z tym hasÅ‚em?â€

NieodÅ‚Ä…cznym elementem autoryzacji jest potrzeba udowodnienia, Å¼e ty, jako osoba wysyÅ‚ajÄ…ca zapytanie, jesteÅ› tym za kogo siÄ™ podajesz.

Najprostszym sposobem jest uÅ¼ycie zwykÅ‚ego hasÅ‚a dostÄ™pu, powiÄ…zanego z kontem danego uÅ¼ytkownika. Jednak sama obecnoÅ›Ä‡ hasÅ‚a stwarza zagroÅ¼enie dla
developera aplikacji - hasÅ‚a mogÄ… bowiem wyciec, czy zostaÄ‡ ukradzione. Dlatego naleÅ¼y zastanowiÄ‡ siÄ™ w jaki sposÃ³b takie hasÅ‚o moÅ¼na bezpiecznie
przechowywaÄ‡. Tutaj pojawiajÄ… siÄ™ dwa sÅ‚owa: hashowanie oraz enkrypcja. PoniÅ¼ej definicje z Oxford Languages Dictionary (przetÅ‚umaczone):

**Enkrypcja (Encryption)** - *odwracalny proces zamiany informacji lub danych w kod/szyfr, szczegÃ³lnie aby uniemoÅ¼liwiÄ‡ nieautoryzowany dostÄ™p.*

**Hashowanie (Hashing)** - *zamiana kawaÅ‚ka danych na numeryczny lub alfanumeryczny Å‚aÅ„cuch znakÃ³w za pomocÄ… funkcji, ktÃ³rej rezultat ma zawsze tÄ… samÄ… dÅ‚ugoÅ›Ä‡.*

Do hasÅ‚a jednak, najlepsze jest hashowanie - wtedy, nawet w przypadku wycieku danych, zÅ‚odziej nie jest w stanie odzyskaÄ‡ pierwotnego hasÅ‚a z hashu. Zatem typowy *flow* rejestracji uÅ¼ytkownika oraz
logowania wyglÄ…da nastÄ™pujÄ…co:

Flow rejestracji:

1. HasÅ‚o jako Å‚aÅ„cuch znakÃ³w (plaintext)
2. Hashowane za pomocÄ… wyznaczonej funkcji
3. Przechowujemy tylko hash

Flow logowania:

1. HasÅ‚o jako Å‚aÅ„cuch znakÃ³w (plaintext)
2. Hashowane za pomocÄ… wyznaczonej funkcji
3. WyciÄ…gamy hash hasÅ‚a z bazy danych
4. PorÃ³wnujemy dwie wartoÅ›ci do siebie

Charakterystyka kaÅ¼dej poprawniej funkcji hashujÄ…cej gwarantuje nam unikalny hash dla kaÅ¼dego ciÄ…gu znakÃ³w, i zawsze ten sam hash dla tego samego ciÄ…gu znakÃ³w.

Pozostaje nam pytanie, jaki hash wybraÄ‡? NajpopularniejszÄ… opcjÄ… dla haseÅ‚ jest funkcja haszujÄ…ca â€œbcryptâ€ wynaleziony w 1999 roku.
ZÅ‚oÅ¼onoÅ›Ä‡ hashu powstaÅ‚ego z tej funkcji moÅ¼na modyfikowaÄ‡ wybierajÄ…c liczbÄ™ rund hashowania - implementacja w JS (node.bcrypt.js), jako wartoÅ›Ä‡ domyÅ›lnÄ…, wybiera 10 rund,
a wartoÅ›ciÄ… maksymalnÄ… jest 20. Biblioteka ma bardzo proste API, przykÅ‚adowo, do sprawdzenia czy hasÅ‚o zgadza siÄ™ z hashem wystarczy uÅ¼ycie funkcji `compare`:

```ts
async signIn(email: string, password: string): Promise<LoginResponseDto> {
        const user = await this.usersService.findOne(email);
        if (user === null || !await compare(password, user.password).catch(() => false)) {
            throw new UnauthorizedException();
        }
        return {token: this.generateToken(user.email)};
}
```

### 2. â€Endpoint to koniec drogi zapytania - Interceptorsâ€

Jednak uÅ¼ytkownik moÅ¼e wysyÅ‚aÄ‡ wiele zapytaÅ„, a przesyÅ‚anie i weryfikowanie hasÅ‚a za kaÅ¼dym razem stwarza zagroÅ¼enie bezpieczeÅ„stwa -
powinniÅ›my dÄ…Å¼yÄ‡ do tego, by hasÅ‚o byÅ‚o przesyÅ‚ane jak najrzadszej. Tutaj z pomocÄ… przychodzÄ… ciastka i headery, w ktÃ³rych moÅ¼emy zawrzeÄ‡
dodatkowe informacje, automatycznie, nie robiÄ…c trudu uÅ¼ytkownikowi. O tym czym sÄ… ciastka i headery byÅ‚o opowiedziane, w poprzednich etapach
kursu, dlatego juÅ¼ bez zbÄ™dnego przedÅ‚uÅ¼ania, zastanÃ³wmy siÄ™ jak moÅ¼na ich uÅ¼yÄ‡ do autoryzacji. Najprostszym i najlepszym pomysÅ‚em jest nastÄ™pujÄ…cy
flow zapytania:

Flow kaÅ¼dego zapytania wymagajÄ…cego autoryzacji:

1. Klient automatycznie dodaje unikalnÄ… informacjÄ™ do kaÅ¼dego zapytania
2. Weryfikujemy tÄ… informacjÄ™ na serwerze
3. Zapytanie przechodzi dalej lub zostaje odrzucone

Z pomocÄ… tutaj przychodzÄ… *interceptory*, zwane czasami *filtrami*, czy *guardami*. Idea jest jedna - zareaguj na, przeksztaÅ‚Ä‡, lub odrzuÄ‡ zapytanie.

![interceptors](../../../../../assets/nestjs/auth/int.png)

My zajmiemy siÄ™ tzw. Guards, ktÃ³re dziaÅ‚ajÄ… jak sÅ‚uÅ¼ba celna - majÄ… na celu zbadaÄ‡, czy zapytanie moÅ¼e wejÅ›Ä‡ do naszego endpointâ€™u. Powstaje jednak pytanie, co badaÄ‡ i jak badaÄ‡?

Temat jest bardzo obszerny, ale my skupimy siÄ™ na jednym z najpopularniejszych i
 nie wymagajÄ…cym utrzymania Å¼adnego stanu na naszym serwerze rozwiÄ…zaniu - dziÄ™ki temu nie bÄ™dzie problemÃ³w z utrzymaniem sesji.

Podstawowe kryteria:
- unikalna wartoÅ›Ä‡ dla kaÅ¼dego uÅ¼ytkownika
- z wartoÅ›ci moÅ¼na uzyskaÄ‡ identyfikator uÅ¼ytkownika
- wartoÅ›Ä‡ jest przekazana klientowi podczas logowania

Dodatkowo (dzisiaj siÄ™ tym nie zajmujemy):

- wartoÅ›Ä‡ powinna byÄ‡ unikalna dla kaÅ¼dego logowania
- wartoÅ›Ä‡ powinna mieÄ‡ swÃ³j czas waÅ¼noÅ›ci
- wartoÅ›Ä‡ powinna byÄ‡ zaenkryptowana by uniemoÅ¼liwiÄ‡ zmianÄ™ danych w niej zawartych

Wady rozwiÄ…zania:

- ukradziona wartoÅ›Ä‡ pozwala siÄ™ bez Å¼adnych problemÃ³w podszyÄ‡ pod wÅ‚aÅ›ciciela wartoÅ›ci
- brak wiedzy o zalogowanych urzÄ…dzeniach (wartoÅ›Ä‡ nie jest zaleÅ¼na od urzÄ…dzenia)

OczywiÅ›cie, nawet te problemy majÄ… swoje rozwiÄ…zania, ale w tym poradniku nie bÄ™dziemy siÄ™ nimi przejmowaÄ‡. PoniÅ¼ej znajduje siÄ™ najprostsze rozwiÄ…zanie
speÅ‚niajÄ…ce trzy podstawowe kryteria (**oczywiÅ›cie nie jest ono w Å¼adnym wypadku bezpiecznie - jedynie poglÄ…dowe**)

```ts
// Walidacja tokenÃ³w
async validateToken(token: string): Promise<UserMetadata> {
    return token.startsWith(this.tokenPrefix) ?
        await this.usersService.findMetadataOrFail(token.slice(this.tokenPrefix.length))
        : Promise.reject(new Error("Invalid token"));
}
// Generowanie tokenÃ³w
generateToken(email: string): string {
    return `${this.tokenPrefix}${email}`;
}
```

W NestJS, kaÅ¼dy *Guard* implementuje metodÄ™ `canActivate` zwracajÄ…cÄ… wartoÅ›ci boolean. JeÅ¼eli metoda zwrÃ³ci faÅ‚sz lub rzuci wyjÄ…tek,
zapytanie jest odrzucane. W przypadku wartoÅ›ci `true`, zapytanie przechodzi do nastÄ™pnego interceptora, lub, jeÅ¼eli juÅ¼ nie ma Å¼adnego w kolejce, do naszego
endpointu.

```ts
// Autoryzacja zapytania w interceptorze
async canActivate(context: ExecutionContext): Promise<boolean> {
        const request: RequestWithUser = context.switchToHttp().getRequest();
        const token = this.extractTokenFromHeader(request);
        if (token === undefined) {
            throw new UnauthorizedException("Missing token");
        }
        try {
            request.user = await this.authService.validateToken(token);
        } catch (error) {
            throw new UnauthorizedException((error as Error).message);
        }
        return true;
}
```

### 3. â€Nie zawsze wszystko jest dla wszystkich, czyli po co dzieliÄ‡ nasze endpointy?â€

Przy podstawowej konfiguracji w NestJS, kaÅ¼dy endpoint z adnotacjÄ… `@UseGuards(AuthGuard)` staje siÄ™ prywatny. Analogicznie, wszystkie bez tej adnotacji sÄ… publiczne.

CzÄ™sto wymaganie jest tzw. "Read-Only Public API", czyli API, ktÃ³re jest dostÄ™pne publicznie dla kaÅ¼dego do odczytu, ale jakiekolwiek modyfikacje
wymagajÄ… dodatkowych uprawinieÅ„.

![readonlyAPI](../../../../../assets/nestjs/auth/readonlyAPI.png)

### 4. â€œWspÃ³lne i nasze â€“ Public & Private API patternâ€

Aby uÅ‚atwiÄ‡ i rozgraniczyÄ‡ API, z pomocÄ… przychodzi wzorzec "Public & Private API". Podczas kursu nie bÄ™dziemy uÅ¼ywaÄ‡ tego wzorca, poniewaÅ¼ Å‚amie on niektÃ³re zasady REST. Wspominam o nim, poniewaÅ¼ jest czasami uÅ¼ywany i osobiÅ›cie jestem jego fanem ğŸ‘

Idea jest prosta:

- wszystkie endpointu zaczynajÄ…ce siÄ™ z prefixem `/public` lub `/na` (non-authenticated), itp. sÄ… dostÄ™pne publiczne
- wszystkie inne sÄ… prywatne

![readonlyAPI](../../../../../assets/nestjs/auth/readonlyAPI2.png)

Zalety wzorca to m.in. Å‚atwe instalowanie interceptorÃ³w oraz wiedza co wymaga zalogowania, a co nie, bez zagÅ‚Ä™biania siÄ™ w dokumentacjÄ™.
Jako wady moÅ¼na wymieniÄ‡, obecnoÅ›Ä‡ tych samych zasobÃ³w pod innymi Å›cieÅ¼kami, czy np. dwa razy wiÄ™cej kontrolerÃ³w.

### 5. â€Ta czÄ™Å›Ä‡ jest tylko dla mnie, czyli RBACâ€

Czasami jednak samo zalogowanie siÄ™ na konto nie wystarczy, albowiem nie kaÅ¼dy uÅ¼ytkownik jest rÃ³wny. Pojawia siÄ™ nowe pojÄ™cie, czÄ™sto mylone z tym przez Was juÅ¼ znanym,
czyli Authentication i Authorization.

Authentication, to sprawdzenia kim jest dany uÅ¼ytkownik. MoÅ¼na rozumieÄ‡ to jako przedstawienie siÄ™. Udowodnienie, Å¼e nie jest siÄ™ obcym. Innymi sÅ‚owy, zalogowanie siÄ™.
Authorization, to sprawdzenie jakie uprawnienia ma dany uÅ¼ytkownik. Tutaj metaforom moÅ¼e byÄ‡ sprawdzenie jakie ma wyksztaÅ‚cenie, gdzie pracuje, ile ma lat.

W aplikacjach problem uprawnieÅ„ czÄ™sto siÄ™ pojawia. Najprostszym przykÅ‚adem bÄ™dzie uÅ¼ytkownik zwykÅ‚y oraz uÅ¼ytkownik Administrator. Najprostsze rozwiÄ…zanie (ale nie najlepsze), to **RBAC**, skrÃ³t od **Role Based Access Control**.
KaÅ¼dy uÅ¼ytkownik ma jednÄ…, lub kilka, przypisanych roli, a do niektÃ³rych dziaÅ‚aÅ„ wymagane sÄ… poszczegÃ³lne role.

![interceptors2](../../../../../assets/nestjs/auth/int2.png)

Warto teÅ¼ zaznaczyÄ‡ rÃ³Å¼nicÄ™ pomiÄ™dzy kodem bÅ‚Ä™du 401 i 403. 401 oznacza, Å¼e serwer nie wie kim jesteÅ›. 403 natomiast, oznacza, Å¼e serwer wie kim jesteÅ›, ale nie ma uprawnieÅ„ by zrobiÄ‡ to co chciaÅ‚eÅ›.

Implementacja podstawowego RBAC w NestJS jest prosta. ZaÅ‚Ã³Å¼my, Å¼e kaÅ¼dy uÅ¼ytkownik ma przypisanÄ… jednÄ… rolÄ™.

```ts
// RoleGuard, interceptor, ktÃ³ry sprawdza uprawnienia
@Injectable()
export class RoleGuard implements CanActivate {
    constructor(private reflector: Reflector) {
    }

    canActivate(context: ExecutionContext): boolean {
        const requiredRoles = this.reflector.getAllAndOverride<Role[]>(ROLES_KEY, [
            context.getHandler(),
            context.getClass(),
        ]);
        if (requiredRoles.length === 0) {
            return true;
        }
        const request: RequestWithUser = context.switchToHttp().getRequest();
        return request.user !== undefined && requiredRoles.includes(request.user.role);
    }
}
// dekorator (adnotacja) do endpointÃ³w
export const ROLES_KEY = 'roles';
export const Roles = (...roles: Role[]) => SetMetadata(ROLES_KEY, roles);
```

UÅ¼ycie takiego interceptora jest doÅ›Ä‡ intuicyjne i proste. Wystarczy dodaÄ‡ adnotacjÄ™ `@UserGuards` nad endpointem, tak jak w przypadku naszego "AuthGuard",
oraz adnotacjÄ™ `@Roles` z naszego dekoratora z wymienionymi rolami. PrzykÅ‚adowo, endpoint poniÅ¼ej jest dostÄ™pny jedynie dla administratora.

```ts
@UseGuards(AuthGuard, RoleGuard)
@Roles(Role.ADMIN)
async disableUser(@Param('email') email: string) {
    return this.userService.disableAccount(email);
}
```

Pozostaje jeszcze odpowiedÅº na pytanie, czemu takie rozwiÄ…zanie nie jest najlepsze. Powodem jest iloÅ›Ä‡ rÃ³l, a dokÅ‚adniej nakÅ‚adanie siÄ™ uprawnieÅ„.
PrzykÅ‚ad poniÅ¼ej pochodzi z jednego z projektÃ³w, ktÃ³re pisaÅ‚em (kod jest z Javy):

```java
enum Permission {
    ADMIN(128),
    TEAM_OWNER(64),
    DRIVER(32)
    RACE(16),
    TASK(8),
    EVENT_SEND(4),
    EVENT_RECEIVE(2),
    USER(1),
    BLOCKED(0);
}
```

Co jeÅ¼eli uÅ¼ytkownik moÅ¼e wysyÅ‚aÄ‡ eventy, nie moÅ¼e ich odbieraÄ‡, jest kierowcÄ…, uÅ¼ytkownikiem, moÅ¼e zarzÄ…dzaÄ‡ zadaniami, ale nie moÅ¼e zarzÄ…dzaÄ‡ wyÅ›cigiem?

RozwiÄ…zania sÄ… dwa:

1.  Pozwalamy aby jeden uÅ¼ytkownik miaÅ‚ kilka roli (dodatkowe tabele w bazie danych i overhead na bardzo czÄ™stej operacji)
2.  Tworzymy hybrydowe role: EventSendDriverTaskUser... (i wszystkie moÅ¼liwe kombinacje?)

Å»adne z nich nie jest dobre - sÄ… to limitacje prostego RBAC. Najlepszym rozwiÄ…zaniem jest zmiany systemu kontroli na inny (np. ACL).
Czasami jednak trzeba customowy system samemu napisaÄ‡, bo wiÄ™kszoÅ›Ä‡ frameworkÃ³w oferuje jedynie wbudowane implementacje dla RBAC.

### 6. â€Nie lubimy obcych - CORSâ€

Kilka sÅ‚Ã³w o **CORS** (skrÃ³t od **Cross-Origin Resource Sharing**).

Jest to mechanizm dla przeglÄ…darek internetowych, ktÃ³ry kontroluje czy dana domena moÅ¼e uzyskaÄ‡ zasoby od innej. Przed wysÅ‚aniem prawdziwego
zapytania, klient wysyÅ‚a zapytanie typu OPTIONS, tzw. "preflight request" z danymi klienta, ktÃ³re trafia do pierwszego interceptora na serwerze. Tylko, i tylko wtedy gdy, odpowiedÅº
na to zapytanie jest pozytywna, to klient wysyÅ‚a drugie, juÅ¼ wÅ‚aÅ›ciwe, zapytanie.

![cors](../../../../../assets/nestjs/auth/cors.png)

Konfiguracja CORS w NestJS jest bardzo prosta i wymaga w zasadzie jednej linijki kodu:

```ts
/// main.ts
app.enableCors({
        methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS', 'PATCH'],
        origin: 'http://localhost:5500',
        preflightContinue: false,
});
```
OkreÅ›lamy jakie typy zapytaÅ„ sÄ… dopuszczalne, i jakie ÅºrÃ³dÅ‚a akceptujemy.

### 7. â€Nasze 500, to dalej 500 â€“ Walidatoryâ€

NieodÅ‚Ä…cznÄ… czÄ™Å›ciÄ… kaÅ¼dego API jest walidacja danych wejÅ›ciowych. Pozwala to nie tylko uniknÄ…Ä‡ nieprawidÅ‚owych danych, ale rÃ³wnieÅ¼
uchroniÄ‡ nas przed nieoczekiwanymi bÅ‚Ä™dami. NestJS bez problemÃ³w wspiera rÃ³Å¼ne techniki walidacji danych, a zaczÄ™cie wymaga jedynie instalacji
pakietÃ³w: `npm i --save class-validator class-transformer`.

#### Pipes

Pipe (dosÅ‚owne, ale raczej nie uÅ¼ywane tÅ‚umaczenie - "rura"), to element biblioteki `class-transformer`. Celem jest transformacja i jednoczenie
walidacja danych. SpÃ³jrz na przykÅ‚ad poniÅ¼ej uÅ¼ywajÄ…cy wbudowanej `ParseIntPipe`:

```ts
@Get(":id")
async findOne(@Param("id", ParseIntPipe) id: number) {
    return this.tripService.findOne(id);
}

@Patch(":id")
async update(@Param("id") id: string, @Body() updateTripDto: UpdateTripDto) {
    return this.tripService.update(+id, updateTripDto);
}
```
ZaÅ‚Ã³Å¼my, Å¼e klient wyÅ›le zapytanie, gdzie parametr `id` nie bÄ™dzie liczbÄ….

Pierwsze rozwiÄ…zanie (z `ParseIntPipe`), zwrÃ³ci do klienta odpowiedÅº z kodem 400 i informacjÄ… o ty, Å¼e `id` musi byÄ‡ liczbÄ… caÅ‚kowitÄ….
Drugie zaÅ›, wyrzuci kod bÅ‚Ä™du 500, bo serwer nie moÅ¼e zamieniÄ‡ nie-liczby na liczbÄ™ za pomocÄ… sztuczki z `+`.

### Walidacja DTO

Walidacja DTO jest rÃ³wnieÅ¼ prosta. Nad kaÅ¼dym z pÃ³l wymagajÄ…cych walidacji umieszczamy odpowiednie dekoratory. W przypadku, gdy walidacja zakoÅ„czy siÄ™
bÅ‚Ä™dem, uÅ¼ytkownik dostanie odpowiedÅº z kodem 400 i, opcjonalnie, mniej lub bardzie szczegÃ³Å‚owÄ… wiadomoÅ›ciÄ… o bÅ‚Ä™dzie - zaleÅ¼y to od nas.
Za pomocÄ… wbudowanych walidatorÃ³w moÅ¼na sprawdziÄ‡ wiÄ™kszoÅ›Ä‡ potrzebnych kryteriÃ³w - nazwa walidatora przekazuje co dany walidator sprawdza.

```ts
export class CreateTripDto {
    @IsString()
    @Length(3, 255)
    name: string;

    @IsOptional()
    @IsNumber()
    @Min(0)
    plannedBudget?: number;
}
```

JeÅ¼eli wbudowane walidatory nie wystarczÄ…, moÅ¼emy zawsze stworzyÄ‡ swÃ³j wÅ‚asny. ZaÅ‚Ã³Å¼my, Å¼e celem jest moderacja danych uÅ¼ytkownika - jego status
nie moÅ¼e zawieraÄ‡ pewnych sÅ‚Ã³w.

```ts
// nice-text.validator.ts
@ValidatorConstraint({name: 'niceText', async: false})
export class NiceText implements ValidatorConstraintInterface {
    validate(text: string, _: ValidationArguments) {
        return !text.includes("loser");
    }

    defaultMessage(_: ValidationArguments) {
        return "That's not a nice text, is it?";
    }
}
```

Nasz walidator zawiera metodÄ™ `validate`, ktÃ³ra zwraca faÅ‚sz jeÅ¼eli niedozwolone sÅ‚owo zostanie wykryte, oraz metodÄ™ `defaultMessage` z informacjÄ… dla klienta o tym co poszÅ‚o nie tak.
SposÃ³b uÅ¼ycia customowego walidatora jest taki sam jak tych wbudowanych, poprzez dekorator `@Validate(NazwaKlasyWalidatora):

```ts
export class UserUpdateDto {
  @IsOptional()
  @IsString()
  @MaxLength(30)
  @Validate(NiceText)
  newAboutMe?: string | null;
  @IsOptional()
  @MaxLength(15)
  @IsOptional()
  @IsString()
  name?: string | null;
}
```

## Zadanie do wykonania

Zadanie domowe do wykonania znajduje siÄ™ na [gÅ‚Ã³wnych repozytorium](https://github.com/Solvro/backend-wakacyjne-wyzwanie-2025/blob/main/4.%20Autoryzacja%20i%20walidatory/4.md)

## MateriaÅ‚y

- Link do [nagrania prezentacji](https://drive.google.com/file/d/136PmaiBlXc1wRuipbGF2iG7x-D8HI-r4/view?usp=sharing) z wykÅ‚adu
- Slajdy z prezentacji
- Repozytorium z kodem przedstawionym podczas prezentacji: [link do repozytorium](https://github.com/Solvro/backend-wakacyjne-wyzwanie-2025/blob/main/4.%20Autoryzacja%20i%20walidatory/4.md)
- https://docs.nestjs.com/security
- https://github.com/kelektiv/node.bcrypt.js#readme
- https://github.com/expressjs/cors#configuration-options
- https://github.com/typestack/class-validator (walidatory uÅ¼ywane przez Nest'a)
